<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>POC Geoloc</title>
  <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="geoloc_neo.css">
  <link rel="stylesheet" href="openlayers/ol.css" type="text/css">
  <link rel="stylesheet" href="datepicker/bootstrap-datetimepicker.min.css">
</head>
<body>

  <div class="container-fluid">
    <div class="row">
      <div id="sidebar" class="col-sm-4 col-md-3 menubar">
        <ul class="nav nav-menubar">

          <!-- Formulaire d'identification -->
          <li onclick="toggle('idDiv')"><a href="#">Identifiant Radio</a></li>
          <div id="idDiv" >
            <form id="myForm" onsubmit="return false;">
              <div class="row">
                <div class="col-xs-10 col-xs-offset-1 col-sm-12 col-sm-offset-0 col-md-10 col-md-offset-1">
                  <div id="idInputDiv" class="input-group">
                    <input type="text" class="form-control" name="idRadio" placeholder="Id radio">
                    <span class="input-group-btn">
                      <button id="goButton" class="btn btn-info active" type="button" onclick="login()">Go</button>
                    </span>
                  </div>
                </div>
              </div>
              <div class="row">
                <div class='col-xs-10 col-xs-offset-1 col-sm-12 col-sm-offset-0 col-md-10 col-md-offset-1'>
                  <div class="form-group">
                    <div class='input-group date' id='datetimepicker1'>
                      <input id="finVacation" type='text' placeholder="Date/Heure fin de vacation" class="form-control"/>
                      <span class="input-group-addon">
                        <span class="glyphicon glyphicon-calendar"></span>
                      </span>
                    </div>
                  </div>
                </div>
                <div class="col-xs-10 col-xs-offset-1 col-sm-12 col-sm-offset-0 col-md-10 col-md-offset-1">
                  <label class="radio-inline">
                    <input type="radio" name="type" value="bicycle" checked>
                    <img src="images/bicycle.png" alt="vélo" class="imgButton">
                  </label>
                  <label class="radio-inline">
                    <input type="radio" name="type" value="bike">
                    <img src="images/bike.png" alt="moto" class="imgButton">
                  </label>
                  <label class="radio-inline">
                    <input type="radio" name="type" value="car">
                    <img src="images/car.png" alt="voiture" class="imgButton">
                  </label>
                  <label class="radio-inline">
                    <input type="radio" name="type" value="policeman">
                    <img src="images/policeman.png" alt="piéton" class="imgButton">
                  </label>
                </div>
              </div>
            </form>
          </div>

          <!-- Creer un evenement -->
          <li onclick="toggle('evenementDiv')"><a href="#">Créer un évènement</a></li>
          <div id="evenementDiv" class="row">
            <form id="evenementForm">
              <div class="col-xs-10 col-xs-offset-1 col-sm-10 col-sm-offset-1 col-md-10 col-md-offset-1 col-lg-10 col-lg-offset-1">
                <div class="input-group">
                  <input type="text" class="form-control" name="evtTitre" placeholder="Titre">
                  <span class="input-group-btn">
                    <button class="btn btn-info" type="button" onclick="addEvent()">Créer</button>
                  </span>
                </div>
              </div>
              <div class="col-xs-10 col-xs-offset-1 col-sm-10 col-sm-offset-1 col-md-10 col-md-offset-1 col-lg-10 col-lg-offset-1">
                <textarea class="form-control" rows="3" name="evtDescription" placeholder="Description"></textarea>
              </div>
            </form>
          </div>

          <!-- Exemple de sous-menu  -->
          <li onclick="toggle('loremDiv')"><a href="#">Lorem</a></li>
          <div class="row">
            <p class="col-xs-10 col-xs-offset-1 col-sm-10 col-sm-offset-1" id="loremDiv">Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
          </div>

          <li><a href="#">Analytics</a></li>

          <li><a href="#">Export</a></li>

          <li><a href="#">Analytics</a></li>

          <!-- Exemple de sous-menu -->
          <li onclick="toggle('loremDiv2')" ><a href="#">Lorem</a></li>
          <div class="row">
            <p class="col-xs-10 col-xs-offset-1 col-sm-10 col-sm-offset-1" id="loremDiv2">Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
          </div>

          <li><a href="#">Reports</a></li>

          <li><a href="#">Analytics</a></li>

          <li><a href="#">Export</a></li>
        </ul>

      </div>
      <div id="map" class="col-sm-8 col-sm-offset-4 col-md-9 col-md-offset-3 main"></div>
    </div>
  </div>

  <div id="error" class="popup" style="display:none"></div>
  <div id="notification" class="popup" style="display:none"></div>

  <script src="openlayers/ol.js"></script>
  <script src="proj4js/dist/proj4-src.js"></script>
  <script src="jquery-3.1.1.min.js"></script>
  <script src="elasticsearch/elasticsearch.jquery.js"></script>
  <script src="bootstrap/js/bootstrap.min.js"></script>
  <script src="moment.min.js"></script>
  <script src="datepicker/bootstrap-datetimepicker.min.js"></script>
  <script src="datepicker/fr.js"></script>

  <script>
  const BASE_URL = 'http://plf.poc.plf-sso.ppol.minint.fr/esri';
  const TILE_URL = BASE_URL + '/server/rest/services/PP/FOND_PP_FINAL_512/MapServer';
  var URL_TEMPLATE = TILE_URL + '/tile/{z}/{y}/{x}';
  const LAMBERT93 = "+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";

  const SECOND_IN_MILLIS = 1000;
  const MINUTE_IN_MILLIS = 60*SECOND_IN_MILLIS;

  const REFRESH_TIME = 6 * SECOND_IN_MILLIS;

  const EARTH_RADIUS = 6371.01;

  const _E7 = Math.pow(10, 7);
  const RESOLUTIONS = [
    1322.9193125052918,
    529.1677250021168,
    264.5838625010584,
    185.20870375074085,
    119.06273812547626,
    92.60435187537043,
    66.1459656252646,
    39.687579375158755,
    26.458386250105836,
    13.229193125052918,
    6.614596562526459,
    2.6458386250105836,
    1.3229193125052918,
    0.7937515875031751,
    0.26458386250105836,
    0.13229193125052918,
    0.06614596562526459
  ]

  // Constantes elasticsearch
  const INDEX = 'neo';
  const ES_TYPE = 'tests'
  const _ID = 'neo_id';
  const _X = 'neo_x';
  const _Y = 'neo_y';
  const _ACCURACY = 'neo_accur';
  const _TIMESTAMP = 'neo_timestamp';
  const _HEADING = 'neo_heading';
  const _SPEED = 'neo_speed';
  const _TYPE = 'neo_type';
  const _FIN_VACATION = 'neo_fin'

  var objectId = null, isGPSReady = false, id, type, dateFinVacation = 0;
  // id = identifiantRadio saisi au debut, type = type de vehicule selectionne
  var map, vectorSource;
  var watchID, lastDateQuery = Date.now(), lastDateUpdate = Date.now();
  var allowXHR = true;
  var isMenuVisible = true;
  var form = document.getElementById('myForm');;
  window.app = {};
  var app = window.app;

  var client = new $.es.Client({
    hosts: 'http://plf.poc.plf-sso.ppol.minint.fr/es',
    // apiVersion: '2.4'
  });

  // Initialisation de la map, des boutons (center + menu)
  // + Gestion des events (singleclick et moveend)
  function initMap() {
    proj4.defs("EPSG:2154", LAMBERT93);

    // Debut d'initialisation de l'objet map
    var EPSG_2154 = new ol.proj.Projection({
      code: 'EPSG:2154',
      extent: [503514.6000000015, 6683176.3999999985, 849432.8, 6997025],
      units: 'm'
    });

    // import de la projection de lambert93 dans openlayers
    ol.proj.addProjection(EPSG_2154);

    var tileg = new ol.tilegrid.TileGrid({
      origin: [-3.55975*_E7, 4.89531*_E7],
      resolutions: RESOLUTIONS,
      tileSize: 512
    });

    var point = proj4('EPSG:4326', LAMBERT93, [2.362765, 48.841291]);

    vectorSource = new ol.source.Vector({});

    var freepik = new ol.Attribution({
      html: '<div>Icons made by <a href="http://www.freepik.com" title="Freepik">Freepik</a>'+
      ' from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a>'+
      ' is licensed by <a href="http://creativecommons.org/licenses/by/3.0/"'+
      ' title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></div>'
    });

    var plainicon = new ol.Attribution({
      html: '<div>Icons made by <a href="http://www.flaticon.com/authors/plainicon"'+
      ' title="Plainicon">Plainicon</a> from <a href="http://www.flaticon.com"'+
      ' title="Flaticon">www.flaticon.com</a> is licensed by '+
      '<a href="http://creativecommons.org/licenses/by/3.0/"'+
      ' title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></div>'
    });

    // Ajout des boutons personalises (centerMap + toggleMenu)
    app.RecenterMap = function(opt_options) {
      var options = opt_options || {};
      var button = document.createElement('button');
      button.innerHTML = '<span class="glyphicon glyphicon-screenshot" aria-hidden="true"></span>';

      var this_ = this;
      var handleRecenterMap = function() {
        recenterMap();
      };
      button.addEventListener('click', handleRecenterMap, false);

      var element = document.createElement('div');
      element.className = 'centerButton ol-unselectable ol-control';
      element.appendChild(button);

      ol.control.Control.call(this, {
        element: element,
        target: options.target
      });

    };
    app.ToggleMenu = function(opt_options) {
      var options = opt_options || {};
      var button = document.createElement('button');
      button.innerHTML = '<span class="glyphicon glyphicon-menu-hamburger" aria-hidden="true"></span>';

      var this_ = this;
      var handleToggleMenu = function() {
        toggleMenu();
      };
      button.addEventListener('click', handleToggleMenu, false);

      var element = document.createElement('div');
      element.className = 'toggle ol-unselectable ol-control';
      element.appendChild(button);

      ol.control.Control.call(this, {
        element: element,
        target: options.target
      });

    };
    ol.inherits(app.RecenterMap, ol.control.Control);
    ol.inherits(app.ToggleMenu, ol.control.Control);

    map = new ol.Map({
      controls: ol.control.defaults({
      }).extend([
        new app.RecenterMap(),
        new app.ToggleMenu()
      ]),
      target: 'map',
      layers: [
        new ol.layer.Tile({
          source: new ol.source.XYZ({
            attributions : [freepik, plainicon],
            tileUrlFunction: function(tileCoord, pixelRatio, projection) {
              var z = tileCoord[0];
              var x = tileCoord[1];
              var y = -tileCoord[2] - 1;
              return URL_TEMPLATE.replace('{z}', z.toString())
              .replace('{y}', y.toString())
              .replace('{x}', x.toString());
            },
            projection: EPSG_2154,
            tileGrid: tileg,
          })
        }),
        new ol.layer.Vector({
          source: vectorSource
        })
      ],
      view: new ol.View({
        center: point,
        projection: EPSG_2154,
        maxZoom:15,
        minZoom:2,
        zoom: 10
      })
    });
    // Fin d'initialisation de l'objet map

    // Gestion de l'evenement lorsque la vue de la carte change
    map.on('moveend', function(event) {
      if (!allowXHR) {allowXHR = true;}
      getFeaturesInMapExtent();
    });

    // Suppression de la class disabled (reste present apres un F5)
    $('#goButton').removeAttr('disabled');
    // Initialisation du datetimepicker avec les bonnes options
    $('#datetimepicker1').datetimepicker({
      locale: 'fr',
      // stepping: 5,
      // focusOnShow: false,
      showTodayButton: true,
      showClose: true,
      toolbarPlacement: 'top',
      format: 'MM/DD/YYYY HH:mm',
      minDate: new Date()
    });
    setInterval(getFeaturesInMapExtent, REFRESH_TIME);
  }

  initMap();

  // Permet d'ouvrir ou de fermer le volet du menu dont l'id du div est name
  function toggle(name) {
    if ($('#'+name)[0].hidden) {
      $('#'+name).fadeIn(500);
      $('#'+name)[0].hidden = false;
    }
    else {
      $('#'+name).fadeOut(500);
      $('#'+name)[0].hidden = true;
    }
  }

  // permet de mettre a jour le type, l'idRadio ete la date/heure de fin de vacation
  function refreshId() {
    var idRadio = form.idRadio.value;
    var _type = form.type.value;
    var _date = document.getElementById('finVacation').value;
    if (idRadio != '0000' && idRadio != '' && _type != '') {
      id = idRadio;
      type = _type;
      if (_date != '') {
        var tmp = new Date(_date);
        dateFinVacation = tmp.getTime();
      }
      else {
        dateFinVacation = 0;
      }
    }
  }

  // Permet de mettre automatiquement a jour le type du vehicule sur le formulaire
  function refreshInputRadio(neo_type) {
    switch (neo_type) {
      case "bicycle":
      form.type[0].checked = true;
      break;
      case "bike":
      form.type[1].checked = true;
      break;
      case "car":
      form.type[2].checked = true;
      break;
      case "policeman":
      form.type[3].checked = true;
      break;
      default:
      console.error("je ne dois pas passer ici "+neo_type);
    }
  }

  // Saisie de l'identifiant Radio
  function login() {
    var idRadio = form.idRadio.value;
    var _type = form.type.value;
    var _date = document.getElementById('finVacation').value;
    if (idRadio != '0000' && idRadio != '' && _type != '') {
      id = idRadio;
      type = _type;
      if (_date != '') {
        var tmp = new Date(_date);
        dateFinVacation = tmp.getTime();
      }
      else {
        dateFinVacation = 0;
      }
      $('#goButton').attr('disabled', 'disabled');
      $('#goButton').addClass('disabled');
      $('#goButton').removeClass('btn-info');
      $('#goButton').addClass('btn-danger');
      startUserMode();
    } else {
      showError('Saisie invalide');
    }
  }

  // Lancement de l'application en mode user
  function startUserMode() {
    if (navigator.geolocation) {
      openNotification("Géolocalisation en cours, cliquez sur la carte pour indiquer votre position");
      var point;
      client.search({
        index: INDEX,
        type: ES_TYPE,
        body: {
          query : { match : {"neo_id" : id }}
        }
      }, function(error, response) {
        if (error != undefined) {
          console.error(error);
        } else if (response.hits.total == 0) {
          console.log(id+' non present dans la base');
        } else {
          var feature = response.hits.hits[0];
          objectId = feature._id;
          console.log(objectId);
          point = [feature._source.neo_x, feature._source.neo_y];
          neo_type = feature._source.neo_type;
          refreshInputRadio(neo_type);
          sessionStorage.lastPosition = JSON.stringify(point);
          centerMap(point);
        }

        // Gestion du click simple sur la carte pour l'initialisation manuelle
        // de sa position en attente du fix GPS
        var mapDiv = document.getElementById('map');
        var mousedown_x, mousedown_y, mouseup_x, mouseup_y;

        mapDiv.addEventListener('mousedown', function(event) {
          console.log(event);
          mousedown_x = event.layerX;
          mousedown_y = event.layerY;
        });

        mapDiv.addEventListener('mouseup', function(event) {
          mouseup_x = event.layerX;
          mouseup_y = event.layerY;

          if (mousedown_x == mouseup_x && mousedown_y == mouseup_y) {
            if(!isGPSReady) {
              var coordinates = map.getCoordinateFromPixel([mouseup_x, mouseup_y]);
              var mapPoint = {'x': coordinates[0], 'y': coordinates[1]};
              console.log(mapPoint);
              refreshId();
              if (objectId == null) {
                addFeature(5, 0, 0, mapPoint);
              } else {
                updateFeature(5, 0, 0, mapPoint);
                lastDateUpdate = Date.now();
              }
              updateLocalFeatureGeometry(mapPoint.x, mapPoint.y);
              sessionStorage.lastPosition = JSON.stringify(coordinates);
            }
          }
        })
        getLocation();
      });

    } else {
      showError("Géolocalisation non supportée");
    }
  }

  // Lancement de l'application en mode salle de commandement
  function startAdminMode() {

  }

  // Methode permettant d'afficher et de cacher le menu (seulement sur smartphone)
  function toggleMenu() {
    if (isMenuVisible) {
      document.getElementById('sidebar').style.display = 'none';
      document.getElementById('map').style.top = "0";
      map.updateSize();
      isMenuVisible = false;
    }
    else {
      document.getElementById('sidebar').style.display = 'block';
      document.getElementById('map').style.top = "35%";
      map.updateSize();
      isMenuVisible = true;
    }
  }

  // Methode appelée a chaque modification de la vue de la map
  function recenterMap() {
    console.log("recenter");
    var lastPosition = JSON.parse(sessionStorage.lastPosition); // [x,y] en lambert93
    centerMap(lastPosition);
  }

  // Recentre la carte sur le point donné en argument
  function centerMap(center) {
    map.getView().animate({'center': center, zoom: 11, duration: 750});
  }

  // Initialisation du service de geolocalisation
  function getLocation() {
    watchID = navigator.geolocation.watchPosition(
      function(position) {
        if (!isGPSReady) {
          isGPSReady = true;
          // desactive le clic sur la carte pour indiquer manuellement sa position
          closeNotification();
        }
        updatePosition(position.coords);
      },
      function(error) {
        closeNotification();
        showError(error.message);
      },
      {maximumAge: 5000, enableHighAccuracy: true}
    );
  }

  // Met a jour la position sur la couche portal NEO si et seulement si la derniere
  // mise a jour n'a pas eu lieu dans les 5 dernieres secondes
  function updatePosition(coords) {
    var lat = coords.latitude, lng = coords.longitude, accuracy = coords.accuracy,
    alt = coords.altitude, heading = coords.heading, speed = coords.speed;
    // speed est en mph
    showNotification(lat+", "+lng+" - "+accuracy+"m"); // a supprimer
    if (Date.now() - lastDateUpdate > 5 * SECOND_IN_MILLIS)  {
      addFeature_wgs84(lat, lng, accuracy, heading, mphTokmph(speed));
      lastDateUpdate = Date.now();
    } else {
      console.log("too soon");
    }
  }

  // Utilise proj4js pour la conversion de la lat, lng vers la projection de lambert93
  // Sauvegarde de la dernière position dans sessionStorage
  // Envoi de la position au serveur (mise à jour ou création selon contexte)
  function addFeature_wgs84(lat, lng, accuracy, heading, speed) {
    var tmp = proj4('EPSG:4326', LAMBERT93, [lng, lat]);
    var lastPosition = JSON.stringify([tmp[0], tmp[1]]);
    sessionStorage.lastPosition = lastPosition;
    var mapPoint_2154 = {'x': tmp[0], 'y': tmp[1]};
    refreshId();
    if (objectId == null) {
      addFeature(accuracy, heading, speed, mapPoint_2154);
    } else {
      updateFeature(accuracy, heading, speed, mapPoint_2154);
    }
  }

  function createDocument(id, type, x, y, accuracy, heading, speed, timestamp) {
    var doc = {};
    doc[_ID] = id;
    doc[_TYPE] = type;
    if (dateFinVacation != 0) {
      doc[_FIN_VACATION] = dateFinVacation;
    }
    doc[_X] = x;
    doc[_Y] = y;
    doc[_ACCURACY] = accuracy;
    doc[_TIMESTAMP] = timestamp;
    doc[_HEADING] = heading;
    doc[_SPEED] = speed;
    return doc;
  }

  // Indexation d'un nouveau document dans ES
  function addFeature(accuracy, heading, speed, mapPoint) {
    var doc = createDocument(id, type, mapPoint.x, mapPoint.y, accuracy, heading, speed, Date.now());

    client.index({
      index: INDEX,
      type: ES_TYPE,
      body: doc
    }, function (error, response) {
      if (error != undefined) {
        console.error(error);
      } else {
        objectId = response._id;
        if (!allowXHR) {
          allowXHR = true;
        }
        console.log(objectId);
      }
    });
  }

  // Mise a jour d'un document deja indexe dans ES
  function updateFeature(accuracy, heading, speed, mapPoint) {
    var doc = createDocument(id, type, mapPoint.x, mapPoint.y, accuracy, heading, speed, Date.now());

    client.index({
      index: INDEX,
      type: ES_TYPE,
      id: objectId,
      body: doc
    }, function (error, response) {
      if (error != undefined) {
        console.error(error);
      } else {
        console.log(response);
        if (!allowXHR) {
          allowXHR = true;
        }
      }
    });
  }

  // Permet de mettre a jour localement la position et le type de ma feature
  function updateLocalFeatureGeometry(x, y) {
    var features = vectorSource.getFeatures();
    var length = features.length;
    for (var i = 0; i < length; i++) {
      if (features[i].get('neo_id') == id) {
        refreshId()
        features[i].setGeometry(new ol.geom.Point([x, y]));
        features[i].set('type', type);
        vectorSource.refresh();
        return;
      }
    }
  }

  // /!\ POUR INFO : deplacee dans la methode initMap car il y a du code a executer dans le callback /!\
  // permet de recuperer ma feature (et donc objectID) a partir de mon identifiant radio
  // si et seulement si j'existe deja
  // function getMyFeature() {
  //   client.search({
  //     index: INDEX,
  //     type: ES_TYPE,
  //     body: {
  //       query : { match : {"neo_id" : id }}
  //     }
  //   }, function(error, response) {
  //     if (error != undefined) {
  //       console.error(error);
  //     } else if (response.hits.total == 0) {
  //       console.log(id+' non present dans la base');
  //     } else {
  //       console.log(response.hits.hits[0]);
  //       objectId = response.hits.hits[0]._id;
  //     }
  //   });
  // }

  // Permet d'obtenir les limites(extent) de la vue active de la carte en projection de lambert93
  function getMapExtent() {
    var e = map.getView().calculateExtent(map.getSize());
    var extent = {
      'xmin': e[0],
      'ymin': e[1],
      'xmax': e[2],
      'ymax': e[3],
    }
    return extent;
  }

  // Permet de recuperer uniquement les features qui seront visibles sur la carte
  function getFeaturesInMapExtent() {
    if (Date.now() - lastDateQuery > 5 * SECOND_IN_MILLIS || allowXHR) {
      var geometry = getMapExtent();
      client.search({
        index: INDEX,
        body: {
          query : {
            "bool" : {
              "must" : [
                {"range" : {"neo_x": { "gte" : geometry.xmin, "lte" : geometry.xmax } } },
                {"range" : {"neo_y": { "gte" : geometry.ymin, "lte" : geometry.ymax } } }
              ]
            }
          }
        },
        requestTimeout: 5 * SECOND_IN_MILLIS,
        size: 1000
      }, function(error, response) {
        if (error != undefined) {
          console.error(error);
          if (error.status == 408) {
            showError("Perte de connexion")
          }
        } else {
          console.log(JSON.stringify(response.hits.hits.length));
          refresh(response.hits.hits);
          lastDateQuery = Date.now();
          if (allowXHR) {
            allowXHR = false;
          }
        }
      });
    } else {
      console.log('TOO SOON - getFeaturesInMapExtent');
    }
  }

  // Permet de mettre a jour l'affichage des features
  function refresh(hits) {
    refreshId();
    var i, length = hits.length;
    if (length == 0) return;
    console.log('refresh');
    vectorSource.clear();
    for (i = 0; i < length ; i++) {
      var feature = hits[i];
      var timestamp = feature._source.neo_timestamp;
      var delta = Date.now() - timestamp;
      if (delta > 60*6 * MINUTE_IN_MILLIS) {
        continue;
      }
      if (feature._source.neo_accur > 24) {
        addCircle(feature, delta);
      }
      addMarker(feature, delta);
    }
  }

  // Permet de recuperer la couleur de l'image .png a partir d'une couleur
  function getColor(color) {
    switch (color) {
      case 'red':
      return 'R';
      break;
      case 'blue':
      return 'B';
      break;
      case 'green':
      return 'G';
      break;
      default:
      console.error("getColor : je ne dois pas passer ici "+color);
    }
  }

  // Permet de recuperer un code couleur a partir d'une couleur('red'|'green'|'blue')
  function getColorRGB(color) {
    switch (color) {
      case 'red':
      return '#F00';
      break;
      case 'blue':
      return '#00F';
      break;
      case 'green':
      return '#2EC854';
      break;
      default:
      console.error("getColorRGB : je ne dois pas passer ici "+color);
    }
  }

  // Permet de recuperer une couleur rgba a partir d'une couleur
  function getColorRGBA(color) {
    switch (color) {
      case 'red':
      return 'rgba(255, 0, 0, 0.1)';
      break;
      case 'blue':
      return 'rgba(0, 0, 255, 0.1)';
      break;
      case 'green':
      return 'rgba(0, 255, 0, 0.1)';
      break;
      default:
      console.error("getColorRGBA : je ne dois pas passer ici "+color);
    }
  }

  // Fonction de sytle d'un cercle d'incertitude
  // Permet d'obtenir la bonne couleur d'un cercle d'incertitude
  function circleStyle() {
    return [
      new ol.style.Style({
        stroke: new ol.style.Stroke({
          color: this.get('color'),
          width: 1
        }),
        fill: new ol.style.Fill({
          color: getColorRGBA(this.get('color'))
        })
      })
    ];
  }

  // Fonction de style d'un marker
  // Permet d'obtenir la bonne icone et couleur d'une feature
  function markerStyle() {
    var zoom = map.getView().getZoom();
    var color = this.get('color');
    var suffixe = getColor(color);
    var type = this.get('type');

    return [
      new ol.style.Style({
        text: new ol.style.Text({
          font: '14px Calibri',
          fill: new ol.style.Fill({ color: getColorRGB(color) }),
          offsetY: -15,
          stroke: new ol.style.Stroke({
            color: '#fff', width: 2
          }),
          text: zoom > 8 ? this.get('neo_id') : '', // revoir les param de zoom
        }),
        image: new ol.style.Icon(({
          src: zoom < 5 ? 'images/dot'+suffixe+'.png':
          zoom < 9 ? 'images/'+type+suffixe+'_16.png' :
          'images/'+type+suffixe+'.png'
        }))
      })
    ];
  }

  // Permet d'ajouter un cercle d'incertitude sur la map a partir d'une feature
  // delta : temps depuis la derniere mise a jour de la feature
  function addCircle(feature, delta) {
    var neo_id = feature._source.neo_id;
    var radius = feature._source.neo_accur;
    var x = feature._source.neo_x;
    var y = feature._source.neo_y;
    var circle = new ol.geom.Circle([x, y], radius);
    var feat = new ol.Feature({geometry: circle});
    if (neo_id == id) {
      feat.set('color', 'red');
    } else {
      if (delta > 5 * MINUTE_IN_MILLIS) {
        feat.set('color', 'blue');
      } else {
        feat.set('color', 'green');
      }
    }
    feat.setStyle(circleStyle);
    vectorSource.addFeature(feat);
  }


  // permet d'ajouter un marker sur la map a partir d'une feature
  // delta : temps depuis la derniere mise a jour de la feature
  function addMarker(feature, delta) {
    var neo_id = feature._source.neo_id;
    var x = feature._source.neo_x;
    var y = feature._source.neo_y;
    var neo_type = feature._source.neo_type;
    var point = new ol.geom.Point([x, y]);
    var feat = new ol.Feature({geometry: point});
    if (neo_id == id) {
      feat.set('color', 'red');
    } else {
      if (delta > 5 * MINUTE_IN_MILLIS) {
        feat.set('color', 'blue');
      } else {
        feat.set('color', 'green');
      }
    }
    feat.set('neo_id', neo_id);
    feat.set('type', neo_type);
    feat.setStyle(markerStyle);
    vectorSource.addFeature(feat);
  }


  function mphTokmph(speed) {
    return speed * 1.609344;
  }

  // MESSAGES DE NOTIFICATION ET D'ERREUR
  function showNotification(message) {
    document.getElementById('notification').innerHTML = message;
    $('#notification').fadeIn(400).delay(1500).fadeOut(400);
  }

  function openNotification(message) {
    document.getElementById('notification').innerHTML = message;
    $('#notification').fadeIn(500);
  }

  function closeNotification() {
    $('#notification').fadeOut(200);
  }

  function showError(message) {
    document.getElementById('error').innerHTML = message;
    $('#error').fadeIn(400).delay(2000).fadeOut(400);
  }

  function debugNotif() {
    document.getElementById('notification').innerHTML = 'geolocalisation en cours, cliquez sur la carte pour indiquer votre position';
    document.getElementById('error').innerHTML = 'Perte de connexion';
    $('#notification').fadeIn(500);
    $('#error').fadeIn(500);
  }

  function addEvent() {
    var form = document.getElementById('evenementForm')
    var titre = form.evtTitre.value;
    var description = form.evtDescription.value;
    if (titre != '') {
      var doc = {};
      doc.titre = titre;
      if (description != '') {
        doc.description = description;
      }
      console.log(doc);
      toggle('evenementDiv');
      showNotification('Evenement "'+titre+'" crée');
      form.evtTitre.value = '';
      form.evtDescription.value = '';
    } else {
      showError('Saisie non complète')
    }
  }

  </script>
</body>
</html>
